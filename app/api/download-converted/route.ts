import { NextRequest, NextResponse } from 'next/server';
import archiver from 'archiver';
import { Readable } from 'stream';

interface FileToDownload {
  path: string;
  content: string;
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { projectName, files } = body;

    if (!projectName || !Array.isArray(files) || files.length === 0) {
      return NextResponse.json(
        { error: 'Missing required fields' },
        { status: 400 }
      );
    }

    // Create a new ZIP archive
    const archive = archiver('zip', {
      zlib: { level: 6 }, // Balanced compression
    });

    // Collect chunks in a promise
    const chunks: Buffer[] = [];
    
    const zipPromise = new Promise<Buffer>((resolve, reject) => {
      archive.on('data', (chunk: Buffer) => {
        chunks.push(chunk);
      });
      
      archive.on('end', () => {
        resolve(Buffer.concat(chunks));
      });
      
      archive.on('error', (err) => {
        reject(err);
      });
    });

    // Add a README file
    const readme = `# ${projectName} - Modernized Code

This package contains the modernized version of your codebase, generated by Necro AI.

## Files Converted: ${files.length}

## What Changed:
- Updated to modern JavaScript/TypeScript syntax
- Replaced legacy patterns with modern equivalents
- Improved security and performance
- Added proper error handling

## Next Steps:
1. Review each file carefully
2. Test the modernized code in your environment
3. Update dependencies in package.json
4. Run tests to ensure functionality is preserved

Generated on: ${new Date().toISOString()}
`;

    archive.append(readme, { name: 'README.md' });

    // Add each converted file to the ZIP
    files.forEach((file: FileToDownload) => {
      // Ensure the file path doesn't start with /
      const cleanPath = file.path.startsWith('/') ? file.path.slice(1) : file.path;
      archive.append(file.content, { name: cleanPath });
    });

    // Detect project type and add appropriate configuration
    const hasJavaScript = files.some((f: FileToDownload) => /\.(js|jsx|ts|tsx)$/.test(f.path));
    const hasPHP = files.some((f: FileToDownload) => /\.php$/.test(f.path));
    const hasTypeScript = files.some((f: FileToDownload) => /\.ts$/.test(f.path));
    
    // Add package.json if it's a JavaScript/TypeScript project
    if (hasJavaScript && !files.some((f: FileToDownload) => f.path.includes('package.json'))) {
      const packageJson = {
        name: projectName.toLowerCase().replace(/\s+/g, '-'),
        version: '2.0.0',
        description: 'Modernized codebase generated by Necro AI',
        main: 'index.js',
        type: 'module',
        scripts: {
          start: 'node index.js',
          dev: 'nodemon index.js',
          build: hasTypeScript ? 'tsc' : 'echo "No build needed"',
          test: 'jest',
          lint: 'eslint .',
        },
        keywords: ['modernized', 'necro-ai'],
        author: '',
        license: 'MIT',
        dependencies: {
          ...(hasTypeScript ? {} : {}),
        },
        devDependencies: {
          'nodemon': '^3.0.0',
          'eslint': '^8.0.0',
          ...(hasTypeScript ? {
            'typescript': '^5.0.0',
            '@types/node': '^20.0.0',
          } : {}),
        },
      };
      archive.append(JSON.stringify(packageJson, null, 2), { name: 'package.json' });
    }
    
    // Add .gitignore
    const gitignore = `# Dependencies
node_modules/
vendor/

# Environment
.env
.env.local
.env.*.local

# Build outputs
dist/
build/
*.log

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db
`;
    archive.append(gitignore, { name: '.gitignore' });
    
    // Add TypeScript config if TypeScript files exist
    if (hasTypeScript && !files.some((f: FileToDownload) => f.path.includes('tsconfig.json'))) {
      const tsconfig = {
        compilerOptions: {
          target: 'ES2020',
          module: 'ESNext',
          lib: ['ES2020'],
          outDir: './dist',
          rootDir: './src',
          strict: true,
          esModuleInterop: true,
          skipLibCheck: true,
          forceConsistentCasingInFileNames: true,
          moduleResolution: 'node',
          resolveJsonModule: true,
        },
        include: ['src/**/*'],
        exclude: ['node_modules', 'dist'],
      };
      archive.append(JSON.stringify(tsconfig, null, 2), { name: 'tsconfig.json' });
    }
    
    // Add ESLint config
    if (hasJavaScript && !files.some((f: FileToDownload) => f.path.includes('.eslintrc'))) {
      const eslintrc = {
        env: {
          node: true,
          es2021: true,
        },
        extends: [
          'eslint:recommended',
          ...(hasTypeScript ? ['plugin:@typescript-eslint/recommended'] : []),
        ],
        parserOptions: {
          ecmaVersion: 'latest',
          sourceType: 'module',
        },
        rules: {
          'no-console': 'warn',
          'no-unused-vars': 'warn',
        },
      };
      archive.append(JSON.stringify(eslintrc, null, 2), { name: '.eslintrc.json' });
    }
    
    // Add setup instructions
    const setupGuide = `# Setup Instructions

## Prerequisites
${hasJavaScript ? '- Node.js 18+ and npm/yarn' : ''}
${hasPHP ? '- PHP 8.0+' : ''}
${hasPHP ? '- Composer' : ''}

## Installation

${hasJavaScript ? `### JavaScript/TypeScript Project
\`\`\`bash
# Install dependencies
npm install

# Run development server
npm run dev

# Build for production
npm run build

# Start production server
npm start
\`\`\`
` : ''}

${hasPHP ? `### PHP Project
\`\`\`bash
# Install dependencies
composer install

# Configure your web server to point to the public directory
# Update database credentials in .env file
\`\`\`
` : ''}

## Testing
\`\`\`bash
npm test
\`\`\`

## Important Notes
- Review all modernized code before deploying to production
- Update environment variables in .env file
- Test thoroughly in a staging environment
- Check for any breaking changes in dependencies

## Support
Generated by Necro AI - Legacy Code Resurrection Platform
`;
    archive.append(setupGuide, { name: 'SETUP.md' });

    // Finalize the archive (must be called after all appends)
    archive.finalize();

    // Wait for the ZIP to be fully created
    const zipBuffer = await zipPromise;

    // Convert Buffer to Uint8Array for NextResponse
    const uint8Array = new Uint8Array(zipBuffer);

    // Return the ZIP file as a download
    return new NextResponse(uint8Array, {
      headers: {
        'Content-Type': 'application/zip',
        'Content-Disposition': `attachment; filename="${projectName.replace(/\s+/g, '-').toLowerCase()}-modernized.zip"`,
        'Content-Length': zipBuffer.length.toString(),
      },
    });
  } catch (error) {
    console.error('ZIP creation error:', error);
    return NextResponse.json(
      { error: 'Failed to create ZIP file', details: error instanceof Error ? error.message : 'Unknown error' },
      { status: 500 }
    );
  }
}
